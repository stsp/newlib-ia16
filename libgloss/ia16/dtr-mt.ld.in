#!/bin/sh

set -e
cmd1='#'
cmd2='#'
w1=with
w2=with
case "$1" in
  -nostdlib)
    cmd1='/^@if_starts@/,/^@endif@/ d'
    cmd2='/^@if_libs@/,/^@endif@/ d'
    w1=without
    w2=without;;
  -nostartfiles)
     cmd1='/^@if_starts@/,/^@endif@/ d'
     w1=without;;
  -nodefaultlibs)
     cmd2='/^@if_libs@/,/^@endif@/ d'
     w2=without;;
esac
sed -e "$cmd1" -e "$cmd2" -e "s;@crt0@;$crt0;g" \
    -e "s;@withstarts@;$w1;g" -e "s;@withlibs@;$w2;g" \
    -e "s/@self@/`basename "$0"`/g" -e "/^@if/ d" -e "/^@endif@/ d" <<'EOF'
/*
 * Linker script for terminate-and-stay-resident (TSR) DOS executables with
 * combined data and text segment, @withstarts@ startup files, and @withlibs@
 * default libraries.
 *
 * Generated from @self@.
 */

OUTPUT_FORMAT(binary)
ENTRY(_start)
@if_starts@
INPUT(-l:crtbegin.o -l:crtend.o -l:dtr-t-c0.o)
@endif@
@if_libs@
GROUP(-lc -lgcc -ldos-t -lm)
@endif@

SECTIONS
  {
    . = SEGMENT_START ("text-segment", 0x100);

    /* Target resident text sections.  */
    .text : {
		__stext_keep = .;
		*(.startupA)
		*(.text) *(.text. .text.[^se]* .text.s[^t]* .text.st[^a]*
			   .text.sta[^r]* .text.star[^t]* .text.start[^u]*
			   .text.startu[^p]* .text.startup[^.]* .text.e[^x]*
			   .text.ex[^i]* .text.exi[^t] .text.exit[^.]*)
		__etext_keep = .;
	}
	__ltext_keep = __etext_keep - __stext_keep;

    /* Target resident data sections.  */
    .data : {
		__sdata_keep = .;
		*(.rodata) *(.rodata. .rodata.[^se]* .rodata.s[^t]*
			     .rodata.st[^a]* .rodata.sta[^r]*
			     .rodata.star[^t]* .rodata.start[^u]*
			     .rodata.startu[^p]* .rodata.startup[^.]*
			     .rodata.e[^x]* .rodata.ex[^i]* .rodata.exi[^t]*
			     .rodata.exit[^.]*)
		*(.data) *(.data. .data.[^se]* .data.s[^t]* .data.st[^a]*
			   .data.sta[^r]* .data.star[^t]* .data.start[^u]*
			   .data.startu[^p]* .data.startup[^.]* .data.e[^x]*
			   .data.ex[^i]* .data.exi[^t]* .data.exit[^.]*)
		*(.gcc_except_table)
		__edata_keep = .;
	}

    .bss (NOLOAD) : {
		__sbss_keep = .;
		*(.bss) *(.bss. .bss.[^se]* .bss.s[^t]* .bss.st[^a]*
			  .bss.sta[^r]* .bss.star[^t]* .bss.start[^u]*
			  .bss.startu[^p]* .bss.startup[^.]* .bss.e[^x]*
			  .bss.ex[^i]* .bss.exi[^t]* .bss.exit[^.]*)
		*(COMMON)
		__ebss_keep = .;

		/* Minimum address allowed for sbrk() to use.  */
		__heap_end_minimum = ALIGN(8);
	}

	__ldata_keep = __edata_keep - __sdata_keep;
	__lbss_keep = (__ebss_keep - __sbss_keep + 1) / 2;

    __nokeep_end_maximum = 0xff00;

    /* Size of the transient stack, if the user does not specify one. */
    PROVIDE (__stklen_val_nokeep = 0x300);

    /*
     * Size of the heap, if the user does not specify one.  If the user
     * explicitly specifies a heap size of 0, force a non-zero value.
     *
     * Unfortunately the linker script language does not allow one to say
     * e.g. "allocate a .bss.startup section in such a way that the section
     * _ends_ at a particular address or thereabouts" --- such a feature will
     * allow us to make the heap as large as possible.
     *
     * Because of this limitation, we need to kind of divine a "good" default
     * heap size based on the text & data we have seen so far, without knowing
     * the transient text & data size.  For now, just divide up the remaining
     * space into two equal parts, & allocate the higher part to the transient
     * portion.  FIXME.
     */
    PROVIDE (__heaplen_val = (__nokeep_end_maximum - __heap_end_minimum) / 2);
    __heaplen_val = __heaplen_val ? __heaplen_val : 1;

    /*
     * Target transient text sections.
     *
     * I use the name .text.startup because this is the (input) section name
     * GCC uses by default for startup functions (e.g. static constructors,
     * main (...)).
     */
    .text.startup ALIGN (__heap_end_minimum + __heaplen_val
					    + __stklen_val_nokeep, 2)
		  : AT (__sbss_keep)
	{
		__stack_end_nokeep = .;
		__stext_nokeep_load = LOADADDR (.text.startup);
		__stext_nokeep = .;
		*(.startupB)
		__stext_nokeep_to_copy = .;
		*(.msdos_init) *(.msdos_init.*)
		*(.startupC)
		*(.init)
		*(.startupD)
		*(.text.startup) *(.text.startup.*)
	}
	/*
	 * Distance which the startup code to jump forward by, after we have
	 * copied the code from the LMA to the VMA.
	 */
	__text_nokeep_leap = __stext_nokeep - __stext_nokeep_load;

    .text.exit : {
		*(.exitA)
		*(.fini)
		*(.exitB)
		*(.text.exit) *(.text.exit.*)
		__etext_nokeep = .;
	}

    /* Target transient data sections.  */
    .data.startup : {
		__sdata_nokeep_load = LOADADDR (.data.startup);
		__sdata_nokeep = .;

		/* Build lists of constructors.  */
		KEEP (*crtbegin*.o(.ctors))
		KEEP (*(EXCLUDE_FILE (*crtend*.o ) .ctors))
		KEEP (*(SORT(.ctors.*)))
		KEEP (*(.ctors))

		*(.rodata.startup) *(.rodata.startup.*)
		*(.data.startup) *(.data.startup.*)
	}

    .data.exit : {
		/* Build lists of destructors.  */
		KEEP (*crtbegin*.o(.dtors))
		KEEP (*(EXCLUDE_FILE (*crtend*.o ) .dtors))
		KEEP (*(SORT(.dtors.*)))
		KEEP (*(.dtors))

		*(.rodata.exit) *(.rodata.exit.*)
		*(.data.exit) *(.data.exit.*)

		__edata_nokeep = .;
	}
	__edata_nokeep_load = . + (__sdata_nokeep_load - __sdata_nokeep);
	__lnokeep_to_copy = (__edata_nokeep - __stext_nokeep_to_copy + 1) / 2;

    .bss.startup (NOLOAD) : {
		__sbss_nokeep = .;
		*(.bss.startup) *(.bss.startup.*)
	}

    .bss.exit (NOLOAD) : {
		*(.bss.exit) *(.bss.exit.*)
		__ebss_nokeep = .;
	}
	__lbss_nokeep = (__ebss_nokeep - __sbss_nokeep + 1) / 2;

    ASSERT(. <= __nokeep_end_maximum, "Error: too large for a .com file.")
    /*
     * Used by the memory resizing and DPMI initialization code in
     * dos-models-crt0.S.
     */
    __msdos_initial_alloc_paras = 0x1000;

    /DISCARD/ : { *(.*) }
  }
EOF
